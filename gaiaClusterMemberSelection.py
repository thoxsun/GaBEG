"""
@author: Thomas Suntinger

Import recommendation:

  
Input:
  - load: Gaia query data set as csv file (e.g. from GAIA_query_circle.py)
  - load: Proper motion cluster member selection as csv file 
          (e.g. generated by:     proper_motion_evaluation_loop.py)
  - load: Radial velocity cluster member selection as csv file 
          (e.g. generated by:     gaiaRadVelSelection.py)
  - load: Parallax cluster member selection as csv file 
          (e.g. generated by:     gaiaParallaxSelection.py)
  
  - load: Simbad cluster member reference set as csv file
          (unfinished)
  
Dependencies:
  - sys
  - GAIA_load.py
  - GAIA_save.py

Dependencies for visualization:
  - matplotlib
  - plotStyle.py
  - GAIA_plot.py

Functionality:
  - Script loads different single cluster member parameter selection data sets,
    and compares them to each other.
  - csv files of the different parameter convolutions 
    and of the final member selection are stored (see Output)
  - The comparisons are also visualized in a variaty of plots (see Output plots)
  - Number of stars in each convolution, residues, and more are printed 
    to console or stored as text file (see Output)
    

Structure ( & parameters):
  - Init 
  - Plot settings 
      (figure height)
      (default plot colors)
  - Toggle plots on / off (see 'Structure:Output plots')
  - Toggle print to text file
  - Load /Store data settings 
      (path-, file- & data set names)
  - Cluster selection parameters
      (coordinate center and radius of selected cluster)
      (apparent RGB AGB brightness threshold in mag)
      
  - Proper motion selection plot inputs (see input)
  - Proper motion selection spatial distribution and CMD plot
      (marker specifications)
      
  - Radial velocity selection load from gaiaRadVelSelection (see input)
  - Radial velocity selection spatial distribution and CMD plot
  
  - Parallax selection load from gaiaParallaxSelection (see input)
  - Parallax selection spatial distribution and CMD plot
  
  - Convolution of parameter selection comparison above RGB AGB threshold
  - Convolution of parameter selection comparison above RGB AGB threshold CMD plot 
  
  - Store cluster member selection
  
  - Simbad + Single parameter CMD comparison (unfinished)
  
  
Output:
  - print: see log file.txt as example
  - store: log as text file (All print() output normaly found in console)
  
  - store: csv files for each exclusive single parameter selection (pm,par,radVel)
  - store: csv files for each exclusive douple parameter selection (pm&par,...)
  - store: csv files for each exclusive triple parameter selection (pm&par&radVel)

  - store: csv file of cluster member selection
  
  
Output plots:
  - proper motion selection spatial distribution and CMD 
  - radial velocity selection spatial distribution and CMD
  - parallax selection spatial distribution and CMD
  - Convolution of parameter selection comparison CMD
  
Improvements:
  - Clean unnecessary comments and lines of code
  - Write documentation and improve in code documentation.
  
  - Fix necessary console restart, when store print() is disabled!
  - Find and include a cluster member reference set
  - Make plot to compare it with Gaia selection
  
  - Bonus: Gaia query includes proper motion filter (pm error < 10% of value)
            - Exclude in query, 
            - deal with it in pm eval / pm selection
            - Add invalid pm in 'Structure:Proper motion selection plot inputs' 
  
  

    
"""
#%% Init

import numpy as np
import matplotlib.pyplot as plt
import GAIA_plot as gp


#%% ### ------------ Set default plot style------------------------------------
#https://matplotlib.org/stable/api/figure_api.html#module-matplotlib.figure

# Note: fig_width is fixed in plotStyle.py for MasterThesis specifications
#       fig_height can and should be adjusted to special needs of individual plots
#       fig_height of 5inch is approximatelly half of height on A4 MasterThesis      
fig_height = 5
import plotStyle
[ready_to_publish, fig_height, fig_width] = plotStyle.set_plot_style(fig_height=fig_height)



#%% ### ------------ Set default plot colors ----------------------------------

t00 = 'lightgrey'
t01 = 'grey'
t02 = 'black' 

t_fit = 'black'
t_lost = 'firebrick'
# pm 0.5
t03 = 'silver'
t03 = 'darkgreen'
# pm 1.0 & zpc_pm1.0 & pm 1.0 Ag
t04 = 'whitesmoke'
t04 = 'purple'
# rad velocity
t_rv = 'blue'
# Simbad
t05 = 'forestgreen'
# parallax
t06 = 'lightseagreen'

# dataDR3 - Starhorse convolution
t07 = 'orangered'

# Av extinction models
t08 = 'lightgrey'

# RGB
t09 = 'teal'
# AGB
t10 = 'purple'


#%% ### -------------- toggle plots -------------------------------------------


proper_motion_evaluation_on     = True
radial_velocity_evaluation      = True
cluster_member_selection_on     = True

savefig                         = True

#%% ------------------ toggle print to text file ------------------------------

print_to_text_file = False

#%% ### ------------ Cluster selection parameters

# Cluster center coordinates
coord_center_M5 = 229.638417,2.081028

# Search cone radius in unit degrees
radius_M5 = 0.15

# apparent RGB AGB brightnes threshold in mag
rgb_agb_lower_bound = 12.3

# Evaluation only above threshold 
only_above_RGB_AGB_threshold = True


#%% ### ------------ Load /Store data settings --------------------------------

## ---------Store GAIA selection data -----------------------------------------

file_sub_path = 'data/clusterMemberSelection/'
from GAIA_save import save_gaia as save_gaia
save_data = True

## ---------Store print to text file. -----------------------------------------
# import sys
# if print_to_text_file is True: 
#   sys.stdout = open(file_sub_path+'clusterMemberSelection_log.txt','wt')


## -------------- GAIA data ---------------------------------------------------
# data_set_selected = 'Gaia_M3_r-18arcmin.csv'
data_set_selected = 'Gaia_M5_r-9arcmin.csv'

file_name = data_set_selected[:-4]



## ------------ load data into variables --------------------------------------

from GAIA_load import load_query as load_query
folder_name = 'data/queryData/'

#---------Load GAIA query --------------------------------

file_data = load_query(folder_name + data_set_selected)
gaia_dr3_array = file_data
label_gaia_dr3_array = 'Data sample'
label_gaia_dr3_array_n = 'Data sample ('+str(gaia_dr3_array.size)+' stars)'

# Gaia query in total
print()
print('Gaia query ('+str(gaia_dr3_array.size)+')')
print()
print()


## -------------- Simbad data -------------------------------------------------
# 2023-02-26: CDS-Xmath not accessible
# reference_set_selected = '/CDS-Xmatch_GAIAEDR3_Simbad_M5_8arcmin_starMatchRadius5arcsec.csv'

# #---------Load Simbad query --------------------------------

# simbad_array = load_query(folder_name + reference_set_selected)
# label_simbad_array = 'Simbad data'
# label_simbad_array_n = 'Simbad data ('+str(simbad_array.size)+' stars)'




#%% ### proper motion selection plot inputs ----------------------------------  
print('Proper motion single parameter selection')
# ---------Load proper motion selection ---------------------------------------
# Input from: csv file generated by proper_motion_evaluation_loop.py

# pm selection
folder_name = 'data/pmData/'
data_set_selected = 'Gaia_M5_r-9arcmin_round1_pm_iso_1' 
gaia_dr3_array_pm_selection = load_query(folder_name + data_set_selected)
# pm selection label
label_gaia_dr3_array_pm_selection = 'pm selection'
label_gaia_dr3_array_pm_selection_n = 'pm selection ('+str(gaia_dr3_array_pm_selection.size)+' stars)'
print(label_gaia_dr3_array_pm_selection_n)

# pm residue between selection and Gaia query 
equal_mask = np.isin(gaia_dr3_array['source_id'],gaia_dr3_array_pm_selection['source_id'])
gaia_dr3_array_not_in_pm_selection = gaia_dr3_array[np.logical_not(equal_mask)]
label_gaia_dr3_array_not_in_pm_selection = 'lost stars'
label_gaia_dr3_array_pm_selection_n = 'Residue pm to query ('+str(gaia_dr3_array_not_in_pm_selection.size)+' stars)'
print(label_gaia_dr3_array_pm_selection_n)

# pm selection above threshold
if only_above_RGB_AGB_threshold is True:
  mask = (gaia_dr3_array_pm_selection['phot_g_mean_mag'] < rgb_agb_lower_bound )
  gaia_dr3_array_pm_selection_rgb = gaia_dr3_array_pm_selection[mask]
  label_gaia_dr3_array_pm_selection_rgb = 'pm selection'
  label_gaia_dr3_array_pm_selection_rgb_n = 'pm selection brighter '+ str(rgb_agb_lower_bound)+' mag ('+str(gaia_dr3_array_pm_selection_rgb.size)+' stars)'
  print(label_gaia_dr3_array_pm_selection_rgb_n)

# pm residue between selection and Gaia query above RGB AGB threshold
gaia_dr3_array_not_in_pm_selection_rgb = gaia_dr3_array_not_in_pm_selection[(gaia_dr3_array_not_in_pm_selection['phot_g_mean_mag'] < rgb_agb_lower_bound)]
label_gaia_dr3_array_not_in_pm_selection_rgb = 'lost stars brighter '+ str(rgb_agb_lower_bound)+' mag'
#
label_gaia_dr3_array_not_in_pm_selection_rgb_n = 'Residue pm to query brighter '+ str(rgb_agb_lower_bound)+' mag ('+str(gaia_dr3_array_not_in_pm_selection_rgb.size)+' stars)'
print(label_gaia_dr3_array_not_in_pm_selection_rgb_n)
print()
print()  





#%% ### proper motion selection spatial distribution and CMD plot ------------

if proper_motion_evaluation_on is True:
  
  marker_size = 0.4
  marker_alpha = 0.4
  
  marker_size_lost = 30
  marker_alpha_lost = 1
  marker = '+'
  
  # import matplotlib.gridspec as gridspec
  
  pos_fig, pos_ax = plt.subplots(1,2,figsize=(fig_width,fig_height*0.6),gridspec_kw={'width_ratios':[2,1]},sharex=False,sharey=False)
  
  # gs = gridspec.GridSpec(1, 2,width_ratios=[2,1])
  
  pos_ax[0].scatter(gaia_dr3_array_pm_selection['ra'],gaia_dr3_array_pm_selection['dec'],label=label_gaia_dr3_array_pm_selection,s=marker_size,alpha=marker_alpha,color=t04)
  pos_ax[0].scatter(gaia_dr3_array_not_in_pm_selection_rgb['ra'],gaia_dr3_array_not_in_pm_selection_rgb['dec'],label=label_gaia_dr3_array_not_in_pm_selection_rgb,marker = marker,s=marker_size_lost,alpha=marker_alpha_lost,color=t02)
  
  circle_cluster = plt.Circle(coord_center_M5, radius_M5, color='black', fill=False)
  pos_ax[0].add_patch(circle_cluster)
  
  pos_ax[0].set_ylabel(r'dec')
  pos_ax[0].set_xlabel(r'ra')
  
  pos_ax[0].legend()
  pos_ax[0].set_aspect('equal', adjustable='box')
  
  
 
  
  pos_ax[1].scatter(gaia_dr3_array_pm_selection['bp_rp'],gaia_dr3_array_pm_selection['phot_g_mean_mag'],label=label_gaia_dr3_array_pm_selection, s=marker_size,alpha=marker_alpha,color=t04)  
  pos_ax[1].scatter(gaia_dr3_array_not_in_pm_selection_rgb['bp_rp'],gaia_dr3_array_not_in_pm_selection_rgb['phot_g_mean_mag'],label=label_gaia_dr3_array_not_in_pm_selection_rgb,marker = marker,s=marker_size_lost,alpha=marker_alpha_lost,color=t02)  
  pos_ax[1].axhline(rgb_agb_lower_bound, linestyle = 'dashed', color = 'k',linewidth=0.5, zorder = 1.5)  
    
  
  pos_ax[1].set_xlabel('BP-RP [mag]')
  pos_ax[1].set_ylabel('phot_g_mean_mag [mag]')
  pos_ax[1].invert_yaxis()
  # pos_ax[1].legend(loc = 'lower center')
  
    
  # pos_ax[0,i].set_aspect('equal', adjustable='box')
  # pos_ax[1].set_aspect('equal')
 
  
  fig_sub_path = 'gfx/pm_eval/'
  fig_name = data_set_selected
  
  if savefig is True:
    pos_fig.savefig(fig_sub_path+fig_name+'_pm_pos_cmd')





#%% ### radial velocity selection load from gaiaRadVelSelection --------------------  
print('Radial velocity single parameter selection')

folder_name = 'data/radVelData/'

# load valid rad vel (no Nan array)
data_set_selected = 'Gaia_M5_r-9arcmin_valid_radVel' 
gaia_dr3_array_radVel = load_query(folder_name + data_set_selected)
label_gaia_dr3_array_radVel = 'rad Vel'
label_gaia_dr3_array_radVel_n = 'rad Vel ('+str(gaia_dr3_array_radVel.size)+' stars)'
print(label_gaia_dr3_array_radVel_n)

# load radial velocity selection 
data_set_selected = 'Gaia_M5_r-9arcmin_radVel_iso_1' 
gaia_dr3_array_radVel_selection = load_query(folder_name + data_set_selected)
label_gaia_dr3_array_radVel_selection = 'rad vel selection'
label_gaia_dr3_array_radVel_selection_n = 'rad vel selection ('+str(gaia_dr3_array_radVel_selection.size)+' stars)'
print(label_gaia_dr3_array_radVel_selection_n)

# load residue between (valid-) and (enclosed by isopleth 1.0 prop max) rad vel 
# field stars (non cluster members)
data_set_selected = 'Gaia_M5_r-9arcmin_excluded_radVel' 
gaia_dr3_array_radVel_excluded = load_query(folder_name + data_set_selected)
label_gaia_dr3_array_radVel_excluded = 'lost stars'
label_gaia_dr3_array_radVel_excluded_n = 'rad vel residue ('+str(gaia_dr3_array_radVel_excluded.size)+' stars)'
print(label_gaia_dr3_array_radVel_excluded_n)

# radial velocity residue between selection and Gaia query above RGB AGB threshold
gaia_dr3_array_radVel_excluded_rgb = gaia_dr3_array_radVel_excluded[(gaia_dr3_array_radVel_excluded['phot_g_mean_mag'] < rgb_agb_lower_bound)]
label_gaia_dr3_array_radVel_excluded_rgb = 'lost stars brighter '+ str(rgb_agb_lower_bound)+' mag'
label_gaia_dr3_array_radVel_excluded_rgb_n = 'rad vel residue brighter '+ str(rgb_agb_lower_bound)+' mag (' +str(gaia_dr3_array_radVel_excluded_rgb.size)+' stars)'
print(label_gaia_dr3_array_radVel_excluded_rgb_n)
print()
print() 


#%% ### radial velocity selection spatial distribution and CMD plot ------------

if radial_velocity_evaluation is True:
   
  marker_size = 0.4
  marker_alpha = 0.4
  
  marker_size_lost = 30
  marker_alpha_lost = 1
  marker = '+'
  
  # import matplotlib.gridspec as gridspec
  
  pos_fig, pos_ax = plt.subplots(1,2,figsize=(fig_width,fig_height*0.6),gridspec_kw={'width_ratios':[2,1]},sharex=False,sharey=False)
  
  # gs = gridspec.GridSpec(1, 2,width_ratios=[2,1])
  
  pos_ax[0].scatter(gaia_dr3_array_radVel_selection['ra'],gaia_dr3_array_radVel_selection['dec'],label=label_gaia_dr3_array_radVel_selection,s=marker_size,alpha=marker_alpha,color=t_rv)
  # pos_ax[0].scatter(gaia_dr3_array_radVel_excluded['ra'],gaia_dr3_array_radVel_excluded['dec'],label=label_gaia_dr3_array_radVel_excluded,marker = marker,s=marker_size_lost,alpha=marker_alpha_lost,color=t02)
  pos_ax[0].scatter(gaia_dr3_array_radVel_excluded_rgb['ra'],gaia_dr3_array_radVel_excluded_rgb['dec'],label=label_gaia_dr3_array_radVel_excluded_rgb,marker = marker,s=marker_size_lost,alpha=marker_alpha_lost,color=t02)
  
  circle_cluster = plt.Circle(coord_center_M5, radius_M5, color='black', fill=False)
  pos_ax[0].add_patch(circle_cluster)
  
  pos_ax[0].set_ylabel(r'dec')
  pos_ax[0].set_xlabel(r'ra')
  
  pos_ax[0].legend()
  pos_ax[0].set_aspect('equal', adjustable='box')
  
  
 
  
  pos_ax[1].scatter(gaia_dr3_array_radVel_selection['bp_rp'],gaia_dr3_array_radVel_selection['phot_g_mean_mag'],label=label_gaia_dr3_array_radVel_selection, s=marker_size,alpha=marker_alpha,color=t_rv)  
  # pos_ax[1].scatter(gaia_dr3_array_radVel_excluded['bp_rp'],gaia_dr3_array_radVel_excluded['phot_g_mean_mag'],label=label_gaia_dr3_array_radVel_excluded,marker = marker,s=marker_size_lost,alpha=marker_alpha_lost,color=t02)  
  pos_ax[1].scatter(gaia_dr3_array_radVel_excluded_rgb['bp_rp'],gaia_dr3_array_radVel_excluded_rgb['phot_g_mean_mag'],label=label_gaia_dr3_array_radVel_excluded_rgb,marker = marker,s=marker_size_lost,alpha=marker_alpha_lost,color=t02)  
  pos_ax[1].axhline(rgb_agb_lower_bound, linestyle = 'dashed', color = 'k',linewidth=0.5, zorder = 1.5)  
    
  
  pos_ax[1].set_xlabel('BP-RP [mag]')
  pos_ax[1].set_ylabel('phot_g_mean_mag [mag]')
  pos_ax[1].invert_yaxis()
  # pos_ax[1].legend(loc = 'lower center')
  
    
  # pos_ax[0,i].set_aspect('equal', adjustable='box')
  # pos_ax[1].set_aspect('equal')
 
  
  fig_sub_path = 'gfx/rad_vel_eval/'
  fig_name = data_set_selected
  
  if savefig is True:
    pos_fig.savefig(fig_sub_path+fig_name+'_pm_pos_cmd')



                                                 


#%% ### parallax selection load from gaiaParallaxSelection --------------------  
print('Parallax single parameter selection')
folder_name = 'data/parData/'

# load invalid zpc data
data_set_selected = 'Gaia_M5_r-9arcmin_zpc_invalid' 
gaia_dr3_array_par_zpc_invalid = load_query(folder_name + data_set_selected)
label_gaia_dr3_array_par_zpc_invalid = 'par zpc invalid'
label_gaia_dr3_array_par_zpc_invalid_n = 'par zpc invalid ('+str(gaia_dr3_array_par_zpc_invalid.size)+' stars)'
print(label_gaia_dr3_array_par_zpc_invalid_n)

# invalid zpc data brighter RGB AGB threshold
gaia_dr3_array_par_zpc_invalid_rgb = gaia_dr3_array_par_zpc_invalid[(gaia_dr3_array_par_zpc_invalid['phot_g_mean_mag'] < rgb_agb_lower_bound)]
label_gaia_dr3_array_par_zpc_invalid_rgb_n = 'par zpc invalid brighter '+ str(rgb_agb_lower_bound)+' mag ('+str(gaia_dr3_array_par_zpc_invalid_rgb.size)+' stars)'
print(label_gaia_dr3_array_par_zpc_invalid_rgb_n)

# load zpc data
data_set_selected = 'Gaia_M5_r-9arcmin_zpc' 
gaia_dr3_array_par_zpc = load_query(folder_name + data_set_selected)
label_gaia_dr3_array_par_zpc = 'par zpc'
label_gaia_dr3_array_par_zpc_n = 'par zpc ('+str(gaia_dr3_array_par_zpc.size)+' stars)'
print(label_gaia_dr3_array_par_zpc_n)
print()

# load parallax selection 
data_set_selected = 'Gaia_M5_r-9arcmin_round2_par_iso_1' 
gaia_dr3_array_par_selection = load_query(folder_name + data_set_selected)
label_gaia_dr3_array_par_selection = 'par selection'
label_gaia_dr3_array_par_selection_n = 'par selection ('+str(gaia_dr3_array_par_selection.size)+' stars)'
print(label_gaia_dr3_array_par_selection_n)

# Residue of paralax selection and Gaia query
equal_mask = np.isin(gaia_dr3_array['source_id'],gaia_dr3_array_par_selection['source_id'])
gaia_dr3_array_not_in_par_selection = gaia_dr3_array[np.logical_not(equal_mask)]
label_gaia_dr3_array_not_in_par_selection = 'lost stars'
label_gaia_dr3_array_not_in_par_selection_n = 'Residue par to query ('+str(gaia_dr3_array_not_in_par_selection.size)+' stars)'
print(label_gaia_dr3_array_not_in_par_selection_n)

# Residue of paralax selection and Gaia query above RGB AGB brightness threshold
gaia_dr3_array_not_in_par_selection_rgb = gaia_dr3_array_not_in_par_selection[(gaia_dr3_array_not_in_par_selection['phot_g_mean_mag'] < rgb_agb_lower_bound)]
label_gaia_dr3_array_not_in_par_selection_rgb = 'lost stars brighter '+ str(rgb_agb_lower_bound)+' mag'
label_gaia_dr3_array_not_in_par_selection_rgb_n = 'Residue par to query brighter '+ str(rgb_agb_lower_bound)+' mag ('+str(gaia_dr3_array_not_in_par_selection_rgb.size)+' stars)'
print(label_gaia_dr3_array_not_in_par_selection_rgb_n)
print()
print()
#%% ### parallax selection spatial distribution and CMD plot ------------
gp.singleClusterMemberSelectionPlot(
                                 memberSelection=gaia_dr3_array_par_selection,
                                 label_memberSelection=label_gaia_dr3_array_par_selection,
                                 memberSelectionColor = t06,
                                 
                                 # noMemberSelection = gaia_dr3_array_not_in_par_selection,
                                 noMemberSelection = gaia_dr3_array_not_in_par_selection_rgb,
                                 
                                 label_noMemberSelection = label_gaia_dr3_array_not_in_par_selection_rgb,
                                 noMemberSelectionColor = 'k',
                                 
                                 cluster_coord_center = coord_center_M5,
                                 cluster_search_radius =  radius_M5,
                                 
                                 brightness_threshold_on = True,
                                 brightness_threshold = rgb_agb_lower_bound,
                                 
                                 savefig = True,
                                 fig_sub_path= 'gfx/par_sel/',
                                 fig_name = data_set_selected
                                 )




                                                 
#%% Convolution of parameter selection comparison above RGB AGB threshold

# only_above_RGB_AGB_threshold = False

if only_above_RGB_AGB_threshold is False:
  print('Convolution of parameter selection comparison')
  # Gaia query total
  print('Gaia query total: '+str(gaia_dr3_array.size))
  # pm selection
  # pm_sel_num_of_stars = 'pm selection ('+str(gaia_dr3_array_pm_selection.size)+')'
  # print(pm_sel_num_of_stars)
else:
  print('Convolution of parameter selection comparison above RGB AGB threshold')
  # Gaia query total
  mask = gaia_dr3_array['phot_g_mean_mag'] < rgb_agb_lower_bound
  print('Gaia query total: '+str((gaia_dr3_array[mask]).size))
  # pm selection
  # mask = gaia_dr3_array_pm_selection['phot_g_mean_mag'] < rgb_agb_lower_bound
  # pm_sel_num_of_stars='pm selection ('+str(gaia_dr3_array_pm_selection[mask].size)+')'
  # print(pm_sel_num_of_stars)


# -----------------------------------------------------------------
# Prepare set of data masks
equal_mask_pm_in_data_sample    = np.isin(gaia_dr3_array['source_id'],gaia_dr3_array_pm_selection['source_id'])
equal_mask_pm_par        = np.isin(gaia_dr3_array_pm_selection['source_id'],gaia_dr3_array_par_selection['source_id'])
equal_mask_pm_radVel     = np.isin(gaia_dr3_array_pm_selection['source_id'],gaia_dr3_array_radVel_selection['source_id'])
equal_mask_pm_par_radVel = equal_mask_pm_par & equal_mask_pm_radVel

equal_mask_radVel_in_data_sample    = np.isin(gaia_dr3_array['source_id'],gaia_dr3_array_radVel_selection['source_id'])
equal_mask_radVel_par    = np.isin(gaia_dr3_array_radVel_selection['source_id'],gaia_dr3_array_par_selection['source_id'])
equal_mask_radVel_pm     = np.isin(gaia_dr3_array_radVel_selection['source_id'],gaia_dr3_array_pm_selection['source_id'])
equal_mask_radVel_pm_par = equal_mask_radVel_par & equal_mask_radVel_pm

equal_mask_par_in_data_sample    = np.isin(gaia_dr3_array['source_id'],gaia_dr3_array_par_selection['source_id'])
equal_mask_par_radVel    = np.isin(gaia_dr3_array_par_selection['source_id'],gaia_dr3_array_radVel_selection['source_id'])
equal_mask_par_pm        = np.isin(gaia_dr3_array_par_selection['source_id'],gaia_dr3_array_pm_selection['source_id'])
equal_mask_par_pm_radVel = equal_mask_par_radVel & equal_mask_par_pm

mask_star_selected_by_at_least_one_parameter = equal_mask_pm_in_data_sample |  \
                                                equal_mask_radVel_in_data_sample | \
                                                 equal_mask_par_in_data_sample

# star_selected_by_at_least_one_parameter
mask_star_selected_by_at_least_one_parameter
star_selected_by_at_least_one_parameter_array = gaia_dr3_array[mask_star_selected_by_at_least_one_parameter]
if only_above_RGB_AGB_threshold is True:
  mask = (star_selected_by_at_least_one_parameter_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  star_selected_by_at_least_one_parameter_array = star_selected_by_at_least_one_parameter_array[mask]
print('star_selected_by_at_least_one_parameter ('+str(star_selected_by_at_least_one_parameter_array.size)+')')

# star_not_selected_by_any_parameter
mask_star_not_selected_by_any_parameter = np.logical_not(mask_star_selected_by_at_least_one_parameter) 
star_not_selected_by_any_parameter_array = gaia_dr3_array[mask_star_not_selected_by_any_parameter]
if only_above_RGB_AGB_threshold is True:
  mask = (star_not_selected_by_any_parameter_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  star_not_selected_by_any_parameter_array = star_not_selected_by_any_parameter_array[mask]
print('star_not_selected_by_any_parameter ('+str(star_not_selected_by_any_parameter_array.size)+')')
print()

#---------------- exclusive single parameter selection ------------------------
print('exclusive single parameter selection')


# Residue (pm par & pm rad vel conv) to pm selection
mask = np.logical_not(equal_mask_pm_par) & np.logical_not(equal_mask_pm_radVel)
gaia_dr3_array_pm_selection_only = gaia_dr3_array_pm_selection[mask]
if only_above_RGB_AGB_threshold is True:
  mask = (gaia_dr3_array_pm_selection_only['phot_g_mean_mag'] < rgb_agb_lower_bound )
  gaia_dr3_array_pm_selection_only = gaia_dr3_array_pm_selection_only[mask]
# print('Residue (pm par & pm rad vel conv) to pm selection: '+str(gaia_dr3_array_pm_selection_only.size))
print('exclusive pm selection: '+str(gaia_dr3_array_pm_selection_only.size))
#store
gaia_dr3_array_pm_selection_only_name = file_name + '_'+'pm' +'_residue'
save_gaia(gaia_dr3_array_pm_selection_only ,gaia_dr3_array_pm_selection_only_name,file_sub_path=file_sub_path)


# Residue (radVel_pm & radVel par conv) to radVel selection
mask = np.logical_not(equal_mask_radVel_pm) & np.logical_not(equal_mask_radVel_par)
gaia_dr3_array_radVel_selection_only = gaia_dr3_array_radVel_selection[mask]
if only_above_RGB_AGB_threshold is True:
  mask = (gaia_dr3_array_radVel_selection_only['phot_g_mean_mag'] < rgb_agb_lower_bound )
  gaia_dr3_array_radVel_selection_only = gaia_dr3_array_radVel_selection_only[mask]
# print('Residue (radVel_pm & radVel par conv) to radVel selection: '+str(gaia_dr3_array_radVel_selection_only.size))
print('exclusive radVel selection: '+str(gaia_dr3_array_radVel_selection_only.size))
#store
gaia_dr3_array_radVel_selection_only_name = file_name + '_'+'radVel' +'_residue'
save_gaia(gaia_dr3_array_radVel_selection_only,gaia_dr3_array_radVel_selection_only_name,file_sub_path=file_sub_path)


# Residue (par_pm & par rad vel conv) to par selection
mask = np.logical_not(equal_mask_par_pm) & np.logical_not(equal_mask_par_radVel)
gaia_dr3_array_par_selection_only = gaia_dr3_array_par_selection[mask]
if only_above_RGB_AGB_threshold is True:
  mask = (gaia_dr3_array_par_selection_only['phot_g_mean_mag'] < rgb_agb_lower_bound )
  gaia_dr3_array_par_selection_only = gaia_dr3_array_par_selection_only[mask]
# print('Residue (par_pm & par rad vel conv) to par selection: '+str(gaia_dr3_array_par_selection_only.size))
print('exclusive par selection: '+str(gaia_dr3_array_par_selection_only.size))
#store
gaia_dr3_array_par_selection_only_name = file_name + '_'+'par' +'_residual'
save_gaia(gaia_dr3_array_par_selection_only,gaia_dr3_array_par_selection_only_name,file_sub_path=file_sub_path)



#------------------------------------------------------------------------------
print()
print('exclusive two parameter selection')

# Residue (pm par rad vel conv) to (pm par conv)
mask = equal_mask_pm_par & np.logical_not(equal_mask_pm_par_radVel) 
pm_par_convolution_array = gaia_dr3_array_pm_selection[mask]
if only_above_RGB_AGB_threshold is True:
  mask = (pm_par_convolution_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pm_par_convolution_array = pm_par_convolution_array[mask]
label_pm_par_convolution_array = 'exclusive pm \& par'

# print('Residue (pm par rad vel conv) to (pm par conv): '+str(pm_par_convolution_array.size))
print('exclusive pm par convolution selection: '+str(pm_par_convolution_array.size))


equal_mask_radVel_pm_par

# Residue (par pm radvel conv) to (par radVel conv)
mask = equal_mask_par_radVel & np.logical_not(equal_mask_par_pm_radVel) 
par_radVel_convolution_array = gaia_dr3_array_par_selection[mask]
if only_above_RGB_AGB_threshold is True:
  mask = (par_radVel_convolution_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  par_radVel_convolution_array = par_radVel_convolution_array[mask]
label_par_radVel_convolution_array = 'exclusive par \& pm'

# print('Residue (par pm radvel conv) to (par radVel conv): '+str(par_radVel_convolution_array.size))
print('exclusive par radVel convolution selection: '+str(par_radVel_convolution_array.size))


# Residue (pm par rad vel conv) to (pm radVel conv)
mask = equal_mask_pm_radVel & np.logical_not(equal_mask_pm_par_radVel) 
pm_radVel_convolution_array = gaia_dr3_array_pm_selection[mask]
if only_above_RGB_AGB_threshold is True:
  mask = (pm_radVel_convolution_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pm_radVel_convolution_array = pm_radVel_convolution_array[mask]
label_pm_radVel_convolution_array = 'exclusive pm \& radVel'

# print('Residue (pm par rad vel conv) to (pm radVel conv): '+str(pm_radVel_convolution_array.size))
print('exclusive pm radVel convolution selection: '+str(pm_radVel_convolution_array.size))

#------------------------------------------------------------------------------

print()
print('exclusive triple parameter selection')
# Convolution of pm, par and rad vel
pm_par_radVel_convolution_array = gaia_dr3_array_pm_selection[(equal_mask_pm_par_radVel)]
if only_above_RGB_AGB_threshold is True:
  mask = (pm_par_radVel_convolution_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pm_par_radVel_convolution_array = pm_par_radVel_convolution_array[mask]
label_pm_par_radVel_convolution_array = 'pm \& par \& rad vel'
# print('pm par radVel selection convolution: '+str(pm_par_radVel_convolution_array .size))
print('exclusive pm par radVel convolution selection: '+str(pm_par_radVel_convolution_array .size))
print()


#%% Convolution of parameter selection comparison above RGB AGB threshold CMD plot 

# Set exclusive field stars in respect to chosen selection criterioun
gaia_dr3_array_only = gaia_dr3_array_not_in_pm_selection

if cluster_member_selection_on is True:

  # background_marker_size = 0.4
  # background_marker_alpha = 0.4
  
  
  
  marker_alpha = 1
  marker = ['o','+','<']
  marker_size = [10,10,10]
  
  
  # import matplotlib.gridspec as gridspec
  
  pos_fig, pos_ax = plt.subplots(1,2,figsize=(fig_width,fig_height*.6),gridspec_kw={'width_ratios':[10,11]},sharex=False,sharey=False)
  # pos_fig, pos_ax = plt.subplots(1,1,figsize=(fig_width,fig_height),sharex=False,sharey=False)
  
  # pos_ax = [pos_ax]
  
  
  # data sample
  mask = (gaia_dr3_array_only['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pos_ax[1].scatter(gaia_dr3_array_only['bp_rp'][mask],\
                    gaia_dr3_array_only['phot_g_mean_mag'][mask],\
                    label= label_gaia_dr3_array,\
                    marker  = marker[0],\
                    s=marker_size[0],\
                    alpha=marker_alpha,\
                    color=t02,\
                    )  
  
    
  pos_ax[1].axhline(rgb_agb_lower_bound, \
                    label = 'bound: '+ str(rgb_agb_lower_bound)+' mag',\
                    linestyle = 'dashed', \
                    color = 'k',\
                    linewidth=0.5, \
                    zorder = 1.5)  
    
  # pm selection only
  mask = (gaia_dr3_array_pm_selection_only['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pos_ax[1].scatter(gaia_dr3_array_pm_selection_only['bp_rp'][mask],\
                    gaia_dr3_array_pm_selection_only['phot_g_mean_mag'][mask],\
                    label= label_gaia_dr3_array_pm_selection,\
                    marker  = marker[0],\
                    s=marker_size[0],\
                    alpha=marker_alpha,\
                    color=t04,\
                    )  
  # Pm par selection
  mask = (pm_par_convolution_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pos_ax[1].scatter(pm_par_convolution_array['bp_rp'][mask],\
                    pm_par_convolution_array['phot_g_mean_mag'][mask],
                    label= label_pm_par_convolution_array,\
                    marker = marker[1],\
                    s=marker_size[1],\
                    alpha=marker_alpha,\
                    color=t06,\
                    )  
  
  # pm par radVel selection 
  mask = (pm_par_radVel_convolution_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pos_ax[1].scatter(pm_par_radVel_convolution_array['bp_rp'][mask],\
                    pm_par_radVel_convolution_array['phot_g_mean_mag'][mask],
                    label=label_pm_par_radVel_convolution_array,\
                    marker = marker[2],\
                    s=marker_size[2],\
                    alpha=marker_alpha,\
                    color='blue',\
                    )  
    
  
  pos_ax[1].set_xlabel('BP-RP [mag]')
  pos_ax[1].set_ylabel('phot_g_mean_mag [mag]')
  pos_ax[1].invert_yaxis()
  # pos_ax[1].legend()
  
  
  
  
  
  marker_size = [0.4,10,10]
  
  # data sample
  # mask = (gaia_dr3_array['phot_g_mean_mag'] > rgb_agb_lower_bound )
  # pos_ax[0].scatter(gaia_dr3_array['bp_rp'][mask],\
  #                   gaia_dr3_array['phot_g_mean_mag'][mask],\
  #                   # label= label_gaia_dr3_array,\
  #                   # marker  = marker[0],\
  #                   # s=marker_size[0],\
  #                   alpha=marker_alpha,\
  #                   color=t02,\
  #                   )  
  
  # data sample
  mask = (gaia_dr3_array_only['phot_g_mean_mag'] < rgb_agb_lower_bound )
  mask = True
  pos_ax[0].scatter(gaia_dr3_array_only['bp_rp'][mask],\
                    gaia_dr3_array_only['phot_g_mean_mag'][mask],\
                    label= label_gaia_dr3_array,\
                    marker  = marker[0],\
                    s=marker_size[0],\
                    alpha=marker_alpha,\
                    color=t02,\
                    )  
  
    
    
  # pm selection only
  mask = (gaia_dr3_array_pm_selection['phot_g_mean_mag'] > rgb_agb_lower_bound )
  mask = True
  pos_ax[0].scatter(gaia_dr3_array_pm_selection['bp_rp'][mask],\
                    gaia_dr3_array_pm_selection['phot_g_mean_mag'][mask],\
                    label= label_gaia_dr3_array_pm_selection,\
                    marker  = marker[0],\
                    s=marker_size[0],\
                    alpha=marker_alpha,\
                    color=t04,\
                    )  
    
  pos_ax[0].axhline(rgb_agb_lower_bound, \
                    label = 'bound: '+ str(rgb_agb_lower_bound)+' mag',\
                    linestyle = 'dashed', \
                    color = 'k',\
                    linewidth=0.5, \
                    zorder = 1.5)  
  
  # Pm par selection
  mask = (pm_par_convolution_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pos_ax[0].scatter(pm_par_convolution_array['bp_rp'][mask],\
                    pm_par_convolution_array['phot_g_mean_mag'][mask],
                    label= label_pm_par_convolution_array,\
                    marker = marker[1],\
                    s=marker_size[1],\
                    alpha=marker_alpha,\
                    color=t06,\
                    )  
  
  # pm par radVel selection 
  mask = (pm_par_radVel_convolution_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
  pos_ax[0].scatter(pm_par_radVel_convolution_array['bp_rp'][mask],\
                    pm_par_radVel_convolution_array['phot_g_mean_mag'][mask],
                    label=label_pm_par_radVel_convolution_array,\
                    marker = marker[2],\
                    s=marker_size[2],\
                    alpha=marker_alpha,\
                    color='blue',\
                    )  
    
  
  pos_ax[0].set_xlabel('BP-RP [mag]')
  pos_ax[0].set_ylabel('phot_g_mean_mag [mag]')
  pos_ax[0].set_xlim(-0.7,2.2)
  pos_ax[0].invert_yaxis()
  # pos_ax[0].legend()
  # pos_ax[0].legend(loc = 'lower center')
  
  fig_sub_path = 'gfx/clus_sel/'
  fig_name = data_set_selected
  
  if savefig is True:
    pos_fig.savefig(fig_sub_path+fig_name+'_cmd_comp.jpg')



#%% Store cluster member selection

# full data sample with zpc parallaxes
# gaia_dr3_array_par_zpc

# single parameter cluster member selection by pm (no zpc)
# gaia_dr3_array_pm_selection

mask_pm_selection_in_zpc    = np.isin(gaia_dr3_array_par_zpc['source_id'],gaia_dr3_array_pm_selection['source_id'])

# zpc for pm selection 
gaia_dr3_array_clusterMemberSelection = gaia_dr3_array_par_zpc[mask_pm_selection_in_zpc]
# Store zpc_pm_selection as clusterMemberSelection
gaia_dr3_array_clusterMemberSelection_name = file_name + '_zpc_pm_clusterMemberSelection'

save_gaia(gaia_dr3_array_clusterMemberSelection,gaia_dr3_array_clusterMemberSelection_name ,file_sub_path=file_sub_path)

print()
print('Cluster member selection')
print('Cluster member selection criterion is: pm' )
print('Stored as: '+gaia_dr3_array_clusterMemberSelection_name)
print()

# Gaia query total
print('Gaia query total: '+str(gaia_dr3_array.size))
# pm selection
pm_sel_num_of_stars = 'pm selection ('+str(gaia_dr3_array_pm_selection.size)+')'
print(pm_sel_num_of_stars)
print('Above threshold of '+str(rgb_agb_lower_bound)+ ' mag:')
# Gaia query total
mask = gaia_dr3_array['phot_g_mean_mag'] < rgb_agb_lower_bound
print('Gaia query total: '+str((gaia_dr3_array[mask]).size))
# pm selection
mask = gaia_dr3_array_pm_selection['phot_g_mean_mag'] < rgb_agb_lower_bound
pm_sel_num_of_stars='pm selection ('+str(gaia_dr3_array_pm_selection[mask].size)+')'
print(pm_sel_num_of_stars)


#%% Simbad + Single parameter CMD comparison 
#2023-02-26: CDS-Xmath not accessible

# label_gaia_dr3_array_pm_selection = 'pm selection'
# label_gaia_dr3_array_pm_selection_n = 'pm selection ('+str(gaia_dr3_array.size)+' stars)'



# rgb_agb_lower_bound = 12.3
# rgb_agb_lower_bound = 20
# equal_mask = np.isin(gaia_dr3_array_pm_selection['source_id'],simbad_array['source_id'])

# #Convolution of simbad and pm
# simbad_pm_convolution_array = gaia_dr3_array_pm_selection[(equal_mask)]
# simbad_pm_convolution_array = gaia_dr3_array_pm_selection
# label_simbad_pm_convolution_array = 'lost stars brighter '+ str(rgb_agb_lower_bound)+' mag'
# print('simbad_pm_convolution_array: '+str(simbad_pm_convolution_array.size))

# # pm only data
# pm_selection_only_array = gaia_dr3_array_pm_selection[np.logical_not(equal_mask)]
# pm_selection_only_array = simbad_array
# label_pm_selection_only_array = 'lost stars brighter '+ str(rgb_agb_lower_bound)+' mag'
# print('pm_selection_only_array: '+str(pm_selection_only_array.size))

# # Simbad only data
# equal_mask = np.isin(simbad_array['source_id'],gaia_dr3_array_pm_selection['source_id'])
# simbad_only_array       =  simbad_array[np.logical_not(equal_mask)]
# label_simbad_only_array = 'lost stars brighter '+ str(rgb_agb_lower_bound)+' mag'
# print('simbad_only_array: '+str(simbad_only_array.size))



# # mask = (gaia_dr3_array_not_in_par_selection['phot_g_mean_mag'] < rgb_agb_lower_bound )
# # gaia_dr3_array_not_in_par_selection_trgb = gaia_dr3_array_not_in_par_selection[mask]

# marker_size = 0.4
# marker_alpha = 0.4

# marker_size_lost = 30
# marker_alpha_lost = 1
# marker = '+'


# import matplotlib.gridspec as gridspec

# pos_fig, pos_ax = plt.subplots(1,2,figsize=(fig_width,fig_height*0.6),gridspec_kw={'width_ratios':[1,1]},sharex=False,sharey=False)






# # Simbad / PM comparison CMD
# pos_ax[0].scatter(simbad_pm_convolution_array['bp_rp'],\
#                   simbad_pm_convolution_array['phot_g_mean_mag'],\
#                   label= label_simbad_pm_convolution_array,\
#                   s=marker_size,\
#                   alpha=marker_alpha,\
#                   color=t05,\
#                   )  
# # Pm selection only
# mask = (pm_selection_only_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
# pos_ax[0].scatter(pm_selection_only_array['bp_rp'][mask],\
#                   pm_selection_only_array['phot_g_mean_mag'][mask],
#                   label='lost '+label_pm_selection_only_array+' stars',\
#                   # marker = marker,\
#                   # s=marker_size_lost,\
#                   alpha=marker_alpha_lost,\
#                   color=t_lost,\
#                   )  

# # Simbad selection only
# mask = (simbad_only_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
# pos_ax[0].scatter(simbad_only_array['bp_rp'][mask],\
#                   simbad_only_array['phot_g_mean_mag'][mask],
#                   label='lost '+label_simbad_only_array+' stars',\
#                   # marker = marker,\
#                   # s=marker_size_lost,\
#                   alpha=marker_alpha_lost,\
#                   color=t_lost,\
#                   )  
  

# pos_ax[0].axhline(rgb_agb_lower_bound, \
#                   label = 'Lower RGB / AGB bound: '+ str(rgb_agb_lower_bound)+' mag',\
#                   linestyle = 'dashed', \
#                   color = 'k',\
#                   linewidth=0.5, \
#                   zorder = 1.5)  
  


# pos_ax[0].set_xlabel('BP-RP [mag]')
# pos_ax[0].set_ylabel('phot_g_mean_mag [mag]')
# pos_ax[0].invert_yaxis()
# pos_ax[0].legend(loc = 'lower center')




# # Simbad / PM comparison CMD
# pos_ax[1].scatter(simbad_pm_convolution_array['bp_rp'],\
#                   simbad_pm_convolution_array['phot_g_mean_mag'],\
#                   label= label_simbad_pm_convolution_array,\
#                   s=marker_size,\
#                   alpha=marker_alpha,\
#                   color=t05,\
#                   )  
# # Pm selection only
# mask = (pm_selection_only_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
# pos_ax[1].scatter(pm_selection_only_array['bp_rp'][mask],\
#                   pm_selection_only_array['phot_g_mean_mag'][mask],
#                   label='lost '+label_pm_selection_only_array+' stars',\
#                   marker = marker,\
#                   s=marker_size_lost,\
#                   alpha=marker_alpha_lost,\
#                   color=t_lost,\
#                   )  

# # Simbad selection only
# mask = (simbad_only_array['phot_g_mean_mag'] < rgb_agb_lower_bound )
# pos_ax[1].scatter(simbad_only_array['bp_rp'][mask],\
#                   simbad_only_array['phot_g_mean_mag'][mask],
#                   label='lost '+label_simbad_only_array+' stars',\
#                   marker = marker,\
#                   s=marker_size_lost,\
#                   alpha=marker_alpha_lost,\
#                   color=t_lost,\
#                   )  
  

# pos_ax[1].axhline(rgb_agb_lower_bound, \
#                   label = 'Lower RGB / AGB bound: '+ str(rgb_agb_lower_bound)+' mag',\
#                   linestyle = 'dashed', \
#                   color = 'k',\
#                   linewidth=0.5, \
#                   zorder = 1.5)  
  


# pos_ax[1].set_xlabel('BP-RP [mag]')
# pos_ax[1].set_ylabel('phot_g_mean_mag [mag]')
# pos_ax[1].invert_yaxis()
# pos_ax[1].legend(loc = 'lower center')


  
# pos_ax[0,i].set_aspect('equal', adjustable='box')
# pos_ax[1].set_aspect('equal')


# fig_sub_path = 'gfx/clus_sel/'
# fig_name = data_set_selected

# if savefig is True:
#   pos_fig.savefig(fig_sub_path+fig_name+'_cmd_comp.jpg')
  
  






              
#%% 
    
